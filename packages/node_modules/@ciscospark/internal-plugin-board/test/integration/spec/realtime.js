/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-board';

import {assert} from '@ciscospark/test-helper-chai';
import {maxWaitForEvent} from '@ciscospark/test-helper-mocha';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import fh from '@ciscospark/test-helper-file';
import {map} from 'lodash';
import uuid from 'uuid';

describe('plugin-board', () => {
  describe('realtime', () => {
    let board, conversation, fixture, participants;
    let mccoy, spock;
    let mccoyRealtimeChannel, spockRealtimeChannel;

    before('create users', () => testUsers.create({count: 2})
      .then((users) => {
        participants = [spock, mccoy] = users;

        return Promise.all(map(participants, (participant) => {
          participant.spark = new CiscoSpark({
            credentials: {
              authorization: participant.token
            }
          });
          return participant.spark.internal.device.register();
        }));
      }));

    before('create conversation', () => spock.spark.internal.conversation.create({
      displayName: 'Test Board Conversation',
      participants
    })
      .then((c) => {
        conversation = c;
        return conversation;
      }));

    before('create channel (board)', () => spock.spark.internal.board.createChannel(conversation)
      .then((channel) => {
        board = channel;
        return channel;
      }));

    before('connect to realtime channel', () => Promise.all(map(participants, (participant) => participant.spark.internal.board.realtime.connectByOpenNewMercuryConnection(board))));

    before('get realtime channels', () => {
      spockRealtimeChannel = spock.spark.internal.board.realtime.realtimeChannels.get(board.channelId);
      mccoyRealtimeChannel = mccoy.spark.internal.board.realtime.realtimeChannels.get(board.channelId);
    });

    before('load fixture image', () => fh.fetch('sample-image-small-one.png')
      .then((fetchedFixture) => {
        fixture = fetchedFixture;
        return fetchedFixture;
      }));

    // disconnect realtime
    after('disconnect realtime channel', () => Promise.all(map(participants, (participant) => participant.spark.internal.board.realtime.disconnectMercuryConnection(board))));

    describe('#config', () => {
      it('shares board values', () => {
        // board values
        assert.isDefined(spockRealtimeChannel.config.pingInterval);
        assert.isDefined(spockRealtimeChannel.config.pongTimeout);
        assert.isDefined(spockRealtimeChannel.config.forceCloseDelay);

        // mercury values not defined in board
        assert.isUndefined(spockRealtimeChannel.config.backoffTimeReset);
        assert.isUndefined(spockRealtimeChannel.config.backoffTimeMax);
      });
    });

    describe('#publish()', () => {
      describe('string payload', () => {
        let uniqueRealtimeData;

        before(() => {
          uniqueRealtimeData = uuid.v4();
        });

        it('posts a message to the specified board', () => {
          const data = {
            envelope: {
              channelId: board,
              roomId: conversation.id
            },
            payload: {
              msg: uniqueRealtimeData
            }
          };

          // confirm that both are connected.
          assert.isTrue(spockRealtimeChannel.connected, 'spock is connected');
          assert.isTrue(mccoyRealtimeChannel.connected, 'mccoy is connected');

          // do not return promise because we want done() to be called on
          // board.activity
          spock.spark.internal.board.realtime.publish(board, data);
          return maxWaitForEvent(5000, 'event:board.activity', mccoyRealtimeChannel)
            .then(({data}) => {
              assert.equal(data.contentType, 'STRING');
              assert.equal(data.payload.msg, uniqueRealtimeData);
            });
        });
      });

      describe('file payload', () => {
        let testScr;

        it('uploads file to spark files which includes loc', () => mccoy.spark.internal.board._uploadImage(board, fixture)
          .then((scr) => {
            assert.property(scr, 'loc');
            testScr = scr;
          }));

        it('posts a file to the specified board', () => {
          const data = {
            envelope: {
              channelId: board,
              roomId: conversation.id
            },
            payload: {
              displayName: 'image.png',
              type: 'FILE',
              file: {
                scr: testScr
              }
            }
          };

          // confirm that both are listening.
          assert.isTrue(spockRealtimeChannel.connected, 'spock is connected');
          assert.isTrue(mccoyRealtimeChannel.connected, 'mccoy is listening');

          spock.spark.internal.board.realtime.publish(board, data);
          return maxWaitForEvent(5000, 'event:board.activity', mccoyRealtimeChannel)
            .then(({data}) => {
              assert.equal(data.contentType, 'FILE');
              assert.equal(data.payload.file.scr.loc, testScr.loc);
              assert.equal(data.payload.displayName, 'image.png');
            });
        });
      });
    });
  });
});
